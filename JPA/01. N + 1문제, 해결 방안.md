# N + 1문제와 해결 방법

하위 엔티티들을 첫 쿼리 실행시 한번에 가져오지 않고, Lazy Loading으로 필요한 곳에서 사용되어 쿼리가 실행될 때 발생하는 문제(fetch type을 eager로 설정하면 조회 즉시 쿼리문이 발생,
Lazy는 우선 프록시 객체로 두는 기법)

> 양방향 관계에서 한곳을 꼭 `@JsonIgnore`처리해야 한다. 아그러면 양쪽에서 서로 호출하여 무한 루프에 걸린다.

> 즉시 로딩은 연관관계가 필요 없는 경우에도 데이터를 항상 조회해서 성능 문제를 발생한다.     
> 항상 지연 로딩을 기본으로 하자!!!(프록시 객체)

## 해결 방법

### 1. 페치 조인 최적화

* 엔티티를 페치 조인(fetch join)을 사용해서 쿼리 1번에 조회
* 단 컬렉션 조회시 카티널 곱으로 인해서 **row수가 증가**하게 된다.(카테시안 곱)
    * 카테시안 곱에 추가 설명을 하자면 각 엔티티가 2개의 엔티티를 가지고 있다고 할때(일대다) 페치조인으로 조회하면 1개의 엔티티가 아닌 연관관계의 엔티티 갯수인 2개의 엔티티가 생겨난다.
    * 이를 해결하기 위해 일대다 필드의 타입을 `set`으로 선하는 방법이 있다.(LinkedHashSet)
    * 또한 `distinct`를 사용하는 것이다.(set보다 list가 적절하다고 판단할 시에 사용)
* fetch join 방식과 비슷한 방식으로 `@Entity Graph`가 있다.(이도 카테시안 곱이 발생)
* fetch join은 Inner join, Entity Graph는 Outer Join
* 추가로 `@NamedEntityGraphs`로 Entity에 관련해서 모든 설정 코드를 추가해야 하는데 Entity가 해야하는 책임이서 벗어난다고 생각될 수 있다.
    * 상황에 따라 유동적인 fetch 전략은 service, repository 계층에서 결정해야 한다고 생각
* 위와 같은 방법은 페이징은 row수가 증가했기 때문에 **페이징은 불가능**하다.

#### 페치조인으로 페이징이 불가능한 이유

* 컬렉션을 페치조인하면 일대다 조인이 발생하므로 데이터가 예측할 수 없이 증가한다.
* 일대다에서일을 기준으로 페이징을 하는 것이 목적이다. 그런데 데이터는 다(N)를 기준으로 row가 생긴다.
* 이 경우 하이버네이트는 경고 로그를 남기고 모든 DB 데이터를 읽어서 메모리에서 페이징을 시도한다. -> 최악의 경우 장애로 이어진다.

### 페치 조인으로 페이징까지 잡기!!!

* `ToOne`(`OneToOne`, `ManyToOne`)관계를 모두 페치 조인한다. (one은 row수를 증가시키지 않는다.)
* 컬렉션은 지연 로딩으로 조회한다.
    * 지연 로딩 성능 최적화를 위해 `hibernate.default_batch_fetch_size`, `@BatchSize`를 적용한다.
    * `@BatchSize`: 개별 최적화
    * 이 옵션을 사용하면 컬렉션이나, 프록시 객체를 한꺼번에 설정한 size만큼 IN 쿼리로 조회한다.

위 방법은 페치 조인과 비교해서 쿼리 호출 수가 약간 증가하지만 DB 데이터 전송량이 감소한다.   
그리고 **페이징이 가능하다!!** (row수가 증가하지 않는다.)

### 2. JPA에서 DTO로 바로 조회

* 일반적인 SQL을 사용할 때 처럼 원하는 값을 선택해서 조회한다.(join)
* 1에 해당하는 엔티티가 가지고 있는 다의 엔티티의 id값을 모아서 where in 절로 조회한다.
* 다의 엔티티를 where in절로 조회하고 `Map<Long, List<Entity>>`의 형태로 매핑한다.
* 일의 id를 key값으로 해당하는 모든 다엔티티가 List에 저장되는 형태

### 3. 쿼리 방식 선택 권장 순서

* 우선 엔티티를 DTO로 변환하는 방법을 선택한다.
* 필요하다면 페치 조인으로 성능을 최적화 한다.
* 그래도 안되면 DTO로 직접 조회하는 방법을 선택한다.
* 최후의 방법은 JPA가 제공하는 네이티브 SQL이나 스프링 JDBC Template을 사용해서 SQL을 직접 사용한다.

## Reference

* [JPA N+1 문제 및 해결방안](https://jojoldu.tistory.com/165)