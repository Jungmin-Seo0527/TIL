# 해싱, 해시함수, 해시테이블

## 0. 요약

* 해시는 데이터를 효율적으로 관리하기 위해, 임의의 길이 데이터를 고정된 길이의 데이터로 매핑하는 것

* 해시 테이블의 시간 복잡도는 O(1)
* 이진탐색트리는 O(logN)
* 충돌 문제 해결
    * 체이닝: 연결리스트로 노드를 계속 추가(메모리 문제 발생)
    * Open Addressing: 해시 함수로 얻은 주소가 아닌 다른 주소에 데이터를 저장할 수 있도록 허용(다음 주소로...)
    * 선형 탐사: 정해진 고정 폭으로 옮겨 해시값의 중복을 피함
    * 제곱 탐사: 정해진 고정 폭을 제곱수로 옮겨 해시값의 중복을 피함

## 1. Hash function

* 데이터의 효율적 관리를 목적으로 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수
* 매핑 전 원래 데이터의 값을 key, 매핑 후 데이터의 값을 해시값(hash value), 매핑하는 과정 자체를 해싱(hashing)이라고 한다.

## 2. Hash collision

* 해시 함수는 해쉬값의 갯수보다 대개 많은 키값을 해쉬값으로 변환(many to one 대응)하기 때문에 해시함수가 서로 다른 두 개의 키에 대해 동일한 해시값을 내는 **해시 충돌(Hash Collision)**
  이 발생하게 된다.

## 3. Hash Table

* 해시 함수를 사용하여 키를 해시값으로 매핑하고, 이 해시값을 색인(index)혹은 주소 삼아 데이터의 값(value)을 키와 함께 저장하는 자료구조
* 데이터가 저장되는 곳을 버깃 또는 슬록이라고 한다.

### Direct - address - table

* 키의 전체 갯수와 동일한 크기의 버킷을 가진 해시테이블
* 장점
    * 해시 충돌 문제가 발생하지 않는다.
* 단점
    * 전체 키가 실제 사용하는 키보다 훨씬 많은 경우 사용하지 않는 키들을 위한 공간까지 마련해야 해서 메모리 효율성이 떨어진다.
* 따라서 보통은 해시 테이블의 크기(M)가 실제 사용하는 키 갯수(N)보다 적은 해시테이블을 운용한다.
* load factor(a) = N/M - 해시 테이블의 한 버킷에 평균 몇 개의 키가 매핑되는가를 나타내는 지표
* Direct address table의 load factor는 1이하이며, 1보다 큰 경우 해시충돌 문제 발생

## 4. Hash Table의 장점

* 적은 리소스로 많은 데이터를 효율적으로 관리할 수 있다.
* 색인(index)에 해시값을 사용함으로써 모든 데이터의 검색, 삽입, 삭제를 빠르게 수행할 수 있다.
* 해시함수는 언제나 동일한 해시값을 리턴하고, 해당 색인만 알면 해시테이블의 크기에 상관없이 데이터에 대단히 빠르게 접근 가능
* 색인은 계산이 간단한 함수(상수시간)로 적동하기 때문에 데이터 엑세스(삽입, 삭제, 탐색)의 시간 복잡도가 `O(1)`을 지향한다.

## 5. Hash Table의 쓰임

* 보안 분야에서 자주 사용
    * 키와 해시값 사이에 직접적인 연관이 없기 때문에 해시값만 가지고는 키를 온전히 복원하기 어렵다.
* 데이터 축약 가능
    * 해시 함수는 길이가 서로 다른 입력데이터에 대해 일정한 길이의 출력을 만들 수 있다.

## 6. Chaning

* 한 버킷당 들어갈 수 있는 엔트리의 수에 제한을 두지 않는다.
* 연결 리스트로 체인처럼 노드를 추가한다.
* 메모리 문제를 야기할 수 있다.

### Chaning의 삽입, 탐색, 삭제 시간 복잡도

* 삽입
    * 베킷 갯수(M), 키의 갯수(N)이 있으면 버킷 하나당 N/M개의 키들이 존재한다.
    * LinkedList로 구현했기에 삽입은 `O(1)`
* 탐색
    * 키값에 해당하는 버킷 찾기 (`O(1)`) + LinkedList 탐색(체인 길이) `O(N/M)`
    * `O(1 + N/M)`
* 삭제
    * 탐색이 `O(1 + N/M)`
    * LinkedList의 삭제 연산 자체의 시간 복잡도는 `O(1)`

## 7. Open addressing

* 체이닝과 달리 한 버킷당 들어갈 수 있는 엔트리가 하나뿐인 해시테이블
* 해시함수로 얻은 주소가 아닌 다른 주소에 데이터를 저장할수 있도록 허용

## 8. Probing(탐사)

* open addressing은 그 구조상 해시충돌 문제가 발생할 수 있다.
* 특정 해시값이 키가 몰리게 되면 효율성이 떨어진다.
* Probing이란 삽입, 삭제, 탐색을 수행하기 위해 해시테이블 내 새로운 주소(해시값)를 찾는 과정

### Linear Probing

* 가장 간단한 방식
* 최초 해시값에 해당하는 버킷에 다른 데이터가 저장되어 있으면, 해당 해시값에서 고정폭(예컨대 1칸)을 옮겨 다음 해시값에 해당하는 버킷에 액세스(삽입, 삭제, 탐색)한다.
* 여기에 데이터가 있으면 고정폭으로 또 옮겨 액세스 한다.

### Quadratic probing

* 고정폭으로 이동하는 선형탐사와 달리 그 폭이 제곱수로 늘어난다.
* 1^2 -> 2^2 -> 3^2
* 여러 개의 서로 다른 키들이 동일한 초기 해시값을 갖는 secondary clustering에 취약

## 9. Doubling hashing

추가 요망...

## Reference

[해싱, 해시 함수, 해시 테이블](https://ratsgo.github.io/data%20structure&algorithm/2017/10/25/hash/)